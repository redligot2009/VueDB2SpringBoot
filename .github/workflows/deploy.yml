name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: vuedb2springboot

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      db2:
        image: icr.io/db2_community/db2:11.5.8.0
        env:
          LICENSE: accept
          DB2INSTANCE: db2inst1
          DB2INST1_PASSWORD: passw0rd
          DBNAME: PHOTODB
          BLU: false
          ENABLE_ORACLE_COMPATIBILITY: false
          UPDATEAVAIL: NO
          TO_CREATE_SAMPLEDB: false
          REPODB: false
          IS_OSXFS: false
          PERSISTENT_HOME: true
          HADR_ENABLED: false
        ports:
          - 50000:50000
        options: >-
          --privileged
          --health-cmd "timeout 10 bash -c '</dev/tcp/localhost/50000'"
          --health-interval 30s
          --health-timeout 10s
          --health-retries 10
          --health-start-period 120s

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Wait for DB2 to be ready
      run: |
        echo "Waiting for DB2 to be ready..."
        for i in {1..30}; do
          if timeout 10 bash -c '</dev/tcp/localhost/50000'; then
            echo "DB2 is ready!"
            break
          fi
          echo "Attempt $i: DB2 not ready yet, waiting 10 seconds..."
          sleep 10
        done

    - name: Run backend tests
      run: |
        cd backend
        mvn clean test -Dspring.profiles.active=db2 -Ddb.url=jdbc:db2://localhost:50000/PHOTODB -Ddb.user=db2inst1 -Ddb.pass=passw0rd
      env:
        DB_URL: jdbc:db2://localhost:50000/PHOTODB
        DB_USER: db2inst1
        DB_PASS: passw0rd

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Run frontend tests
      run: |
        cd frontend
        npm run test:unit || echo "No tests configured"

    - name: Build frontend
      run: |
        cd frontend
        npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Setup SSH key for Terraform
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa

    - name: Get SSH public key content
      id: ssh-public-key
      run: |
        # Extract public key from private key
        ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
        SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        echo "ssh_public_key_content=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT

    - name: Terraform Init
      run: |
        cd terraform
        # Initialize with S3 backend for state persistence
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=vuedb2springboot/terraform.tfstate" \
          -backend-config="region=us-east-1" \
          -backend-config="encrypt=true"

    - name: Check existing infrastructure
      run: |
        cd terraform
        echo "Checking existing Terraform state..."
        terraform show || echo "No existing state found"
        echo ""
        echo "Checking existing EC2 instances..."
        aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=vuedb2springboot-web-server" \
          --query 'Reservations[].Instances[]' \
          --output json > /tmp/instances.json
        
        echo "Raw AWS CLI output (first 500 chars):"
        head -c 500 /tmp/instances.json
        echo ""
        echo ""
        
        # Filter out terminated instances using jq
        jq '[.[] | select(.State.Name != "terminated")]' /tmp/instances.json > /tmp/active-instances.json
        mv /tmp/active-instances.json /tmp/instances.json
        
        INSTANCE_COUNT=$(jq length /tmp/instances.json)
        echo "Found $INSTANCE_COUNT existing instances"
        
        if [ "$INSTANCE_COUNT" -gt 0 ]; then
          echo "Existing instances:"
          # Debug: show the structure of the first instance
          echo "Debug - First instance structure:"
          jq '.[0]' /tmp/instances.json
          echo ""
          echo "Instance list:"
          jq -r '.[] | "  - \(.InstanceId) (\(.State.Name)) - \(.PublicIpAddress // "No public IP")"' /tmp/instances.json
        else
          echo "No existing instances found"
        fi

    - name: Handle existing key pair
      run: |
        cd terraform
        # Delete existing key pair if it exists
        aws ec2 delete-key-pair --key-name vuedb2springboot-key || echo "Key pair doesn't exist, will be created"

    - name: Clean up existing Cloudflare A records
      run: |
        cd terraform
        echo "Cleaning up existing Cloudflare A records for ${{ secrets.DOMAIN_NAME }}..."
        
        # Get existing A records for the domain
        EXISTING_RECORDS=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records?type=A&name=${{ secrets.DOMAIN_NAME }}" \
          -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -H "Content-Type: application/json" | jq -r '.result[].id' 2>/dev/null || echo "")
        
        if [ ! -z "$EXISTING_RECORDS" ]; then
          echo "Found existing A records: $EXISTING_RECORDS"
          for record_id in $EXISTING_RECORDS; do
            echo "Deleting A record: $record_id"
            curl -s -X DELETE "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/dns_records/$record_id" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json" || echo "Failed to delete record $record_id"
          done
          echo "Existing A records cleaned up"
        else
          echo "No existing A records found"
        fi

    - name: Handle EIP limit
      run: |
        cd terraform
        # Release unassociated EIPs to free up quota
        aws ec2 describe-addresses --query 'Addresses[?AssociationId==null].AllocationId' --output text | while read eip; do
          if [ ! -z "$eip" ]; then
            echo "Releasing unassociated EIP: $eip"
            aws ec2 release-address --allocation-id "$eip" || echo "Failed to release EIP: $eip"
          fi
        done

    - name: Clean up orphaned instances
      run: |
        cd terraform
        # Find instances with our project name that are not in Terraform state
        echo "Checking for orphaned EC2 instances..."
        
        # Get all instances with our tag
        aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=vuedb2springboot-web-server" \
          --query 'Reservations[].Instances[]' \
          --output json > /tmp/all-instances.json
        
        # Filter out terminated instances using jq
        jq '[.[] | select(.State.Name != "terminated")]' /tmp/all-instances.json > /tmp/active-all-instances.json
        mv /tmp/active-all-instances.json /tmp/all-instances.json
        
        INSTANCE_COUNT=$(jq length /tmp/all-instances.json)
        echo "Found $INSTANCE_COUNT instances with project tag"
        
        if [ "$INSTANCE_COUNT" -gt 0 ]; then
          echo "Instances found:"
          jq -r '.[] | "  - \(.InstanceId) (\(.State.Name)) - \(.PublicIpAddress // "No public IP")"' /tmp/all-instances.json
          echo ""
          echo "Note: Terraform will manage these instances if they exist in state"
          echo "If they are truly orphaned, they will be replaced by new instances"
        else
          echo "No instances found with project tag"
        fi

    - name: Handle orphaned instances
      run: |
        cd terraform
        # Check if we have orphaned instances and empty state
        if [ -f /tmp/all-instances.json ]; then
          INSTANCE_COUNT=$(jq length /tmp/all-instances.json)
          if [ "$INSTANCE_COUNT" -gt 0 ]; then
            echo "Found $INSTANCE_COUNT existing instances but Terraform state is empty"
            echo "This suggests orphaned instances from previous deployments"
            echo ""
            echo "Strategy: Let Terraform create new instances and manage them properly"
            echo "The old instances will remain but won't be managed by Terraform"
            echo "You can manually terminate them later if needed"
            echo ""
            echo "Instances that will remain unmanaged:"
            jq -r '.[] | "  - \(.InstanceId) (\(.State.Name))"' /tmp/all-instances.json
          fi
        fi

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
          -var="ssh_public_key_content=${{ steps.ssh-public-key.outputs.ssh_public_key_content }}"

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
          -var="ssh_public_key_content=${{ steps.ssh-public-key.outputs.ssh_public_key_content }}"

    - name: Get EC2 Instance IP
      id: get-ip
      run: |
        cd terraform
        INSTANCE_IP=$(terraform output -raw instance_public_ip)
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: Wait for EC2 instance to be ready
      run: |
        echo "Waiting for EC2 instance to be ready..."
        for i in {1..30}; do
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@${{ steps.get-ip.outputs.instance_ip }} 'echo "Instance is ready"'; then
            echo "Instance is ready!"
            break
          fi
          echo "Attempt $i: Instance not ready yet, waiting 30 seconds..."
          sleep 30
        done

    - name: Setup SSH key for deployment
      run: |
        ssh-keyscan -H ${{ steps.get-ip.outputs.instance_ip }} >> ~/.ssh/known_hosts

    - name: Deploy application
      run: |
        # Copy application files to EC2 (to temporary directory first)
        rsync -avz --delete -e "ssh -o StrictHostKeyChecking=no" \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='target' \
          --exclude='.github' \
          ./ ubuntu@${{ steps.get-ip.outputs.instance_ip }}:/tmp/${{ env.PROJECT_NAME }}/
        
        # Move files to final location with sudo
        ssh -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.instance_ip }} "
          sudo mkdir -p /opt/${{ env.PROJECT_NAME }} &&
          sudo rm -rf /opt/${{ env.PROJECT_NAME }}/* &&
          sudo mv /tmp/${{ env.PROJECT_NAME }}/* /opt/${{ env.PROJECT_NAME }}/ &&
          sudo chown -R ubuntu:ubuntu /opt/${{ env.PROJECT_NAME }}
        "

        # Deploy the application
        ssh -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.instance_ip }} << 'EOF'
          cd /opt/${{ env.PROJECT_NAME }}
          
          # Wait for any running package operations to complete
          echo "Waiting for package operations to complete..."
          while sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
            echo "Package manager is busy, waiting..."
            sleep 5
          done
          
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "Docker not found, installing..."
            # Kill any stuck apt processes
            sudo pkill -f apt-get || true
            sudo pkill -f dpkg || true
            sleep 2
            
            # Remove any lock files
            sudo rm -f /var/lib/dpkg/lock-frontend
            sudo rm -f /var/lib/dpkg/lock
            sudo rm -f /var/cache/apt/archives/lock
            
            # Update package list
            sudo apt-get update
            
            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            
            # Create docker group if it doesn't exist
            sudo groupadd docker 2>/dev/null || true
            sudo usermod -aG docker ubuntu
          fi
          
          # Start Docker service
          sudo systemctl daemon-reload
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Wait for Docker to be ready
          echo "Waiting for Docker to be ready..."
          timeout 60 bash -c 'until docker info >/dev/null 2>&1; do sleep 2; done' || {
            echo "Docker failed to start, trying to restart..."
            sudo systemctl restart docker
            sleep 10
          }
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
            echo "Docker Compose not found, installing..."
            # Install Docker Compose v2 (plugin)
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            
            # Also install legacy docker-compose for compatibility
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Prepare JWT expiration value (from secret if set, else default)
          JWT_EXP_VAL="${{ secrets.JWT_EXPIRATION }}"
          if [ -z "$JWT_EXP_VAL" ]; then
            JWT_EXP_VAL=86400000
          fi

          # Create .env file if it doesn't exist
          if [ ! -f .env ]; then
            echo "domain_name=${{ secrets.DOMAIN_NAME }}" > .env
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            echo "JWT_EXPIRATION=$JWT_EXP_VAL" >> .env
          else
            # Update domain_name in .env
            if grep -q "domain_name=" .env; then
              sed -i "s/domain_name=.*/domain_name=${{ secrets.DOMAIN_NAME }}/" .env
            else
              echo "domain_name=${{ secrets.DOMAIN_NAME }}" >> .env
            fi
            # Update JWT_SECRET
            if grep -q "JWT_SECRET=" .env; then
              sed -i "s/JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env
            else
              echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
            fi
            # Update JWT_EXPIRATION (use secret value if provided, else default)
            if grep -q "JWT_EXPIRATION=" .env; then
              sed -i "s/JWT_EXPIRATION=.*/JWT_EXPIRATION=$JWT_EXP_VAL/" .env
            else
              echo "JWT_EXPIRATION=$JWT_EXP_VAL" >> .env
            fi
          fi
          
          # Add production Flyway and JPA configuration to .env
          echo "Adding production configuration to .env..."
          {
            echo "# Production Flyway configuration"
            echo "FLYWAY_ENABLED=true"
            echo "FLYWAY_LOCATIONS=classpath:db/migration"
            echo "FLYWAY_BASELINE_ON_MIGRATE=true"
            echo "FLYWAY_VALIDATE_ON_MIGRATE=true"
            echo "FLYWAY_CLEAN_DISABLED=true"
            echo "# Production JPA configuration"
            echo "JPA_DDL_AUTO=validate"
            echo "JPA_SHOW_SQL=false"
            echo "JPA_FORMAT_SQL=false"
          } >> .env
          
          # Verify Docker is working
          echo "Verifying Docker installation..."
          if ! sudo docker info >/dev/null 2>&1; then
            echo "Docker is not responding, attempting to fix..."
            sudo systemctl restart docker
            sleep 5
            if ! sudo docker info >/dev/null 2>&1; then
              echo "Docker is still not working, trying alternative approach..."
              sudo service docker restart
              sleep 5
            fi
          fi
          
          # Check Docker and Docker Compose versions
          echo "Docker version:"
          sudo docker --version
          echo "Docker Compose version:"
          sudo docker compose version || sudo docker-compose --version
          
          # Check what's using port 80
          echo "Checking what's using port 80..."
          sudo netstat -tlnp | grep :80 || echo "Port 80 is free"
          sudo lsof -i :80 || echo "No processes found using port 80"
          
          # Stop any existing Nginx service on the host that might be using port 80
          echo "Stopping any existing Nginx service on host..."
          sudo systemctl stop nginx || true
          sudo systemctl disable nginx || true
          
          # Kill any processes still using port 80
          echo "Killing any processes still using port 80..."
          sudo fuser -k 80/tcp || true
          
          # Stop existing containers
          echo "Stopping existing containers..."
          sudo docker compose -f docker-compose.prod.yml down || sudo docker-compose -f docker-compose.prod.yml down || true
          
          # Build and start new containers
          echo "Building and starting new containers..."
          sudo docker compose -f docker-compose.prod.yml up -d --build || sudo docker-compose -f docker-compose -f docker-compose.prod.yml up -d --build
          
          # First, run Flyway migrations to ensure schema is up-to-date
          echo "Running Flyway migrations to ensure schema is up-to-date..."
          sudo docker run --rm \
            --network app-network \
            -e SPRING_PROFILES_ACTIVE=production \
            -e DB_URL=jdbc:db2://db2:50000/PHOTODB \
            -e DB_USER=db2inst1 \
            -e DB_PASS=passw0rd \
            -e JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            -e JWT_EXPIRATION="${{ secrets.JWT_EXPIRATION || '86400000' }}" \
            -e FLYWAY_ENABLED=true \
            -e FLYWAY_LOCATIONS=classpath:db/migration \
            -e FLYWAY_BASELINE_ON_MIGRATE=true \
            -e FLYWAY_VALIDATE_ON_MIGRATE=true \
            -e JPA_DDL_AUTO=none \
            --name flyway-migration \
            backend:latest \
            java -cp /app/resources:/app/classes:/app/libs/* org.flywaydb.commandline.Main \
            -url=jdbc:db2://db2:50000/PHOTODB \
            -user=db2inst1 \
            -password=passw0rd \
            -locations=classpath:db/migration \
            migrate
          
          echo "Flyway migrations completed. Starting normal containers..."
          sudo docker compose -f docker-compose.prod.yml up -d
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
          
          # Wait for DB2 to be fully ready
          echo "Waiting for DB2 to be fully ready..."
          for i in {1..10}; do
            if sudo docker exec db2 su - db2inst1 -c "db2 connect to PHOTODB && db2 quit" 2>/dev/null; then
              echo "DB2 is ready!"
              break
            fi
            echo "DB2 not ready yet, attempt $i/10, waiting 30 seconds..."
            sleep 30
          done
          
          # Verify container status
          echo "Container status:"
          sudo docker compose -f docker-compose.prod.yml ps
          
          # Wait for backend to start and monitor Flyway migrations
          echo "Waiting for backend to start and monitoring Flyway migrations..."
          sleep 30
          
          # Check if Flyway migrations are needed by examining the database schema
          echo "Checking current database schema..."
          TABLE_COUNT=$(sudo docker exec db2 su - db2inst1 -c "db2 connect to PHOTODB && db2 -x 'SELECT COUNT(*) FROM SYSCAT.TABLES WHERE TABSCHEMA = '\''DB2INST1'\''' | tail -1" 2>/dev/null || echo "0")
          echo "Current table count: $TABLE_COUNT"
          
          # Monitor backend startup and Flyway execution
          echo "Monitoring backend startup and Flyway execution..."
          for i in {1..15}; do
            echo "Check $i: Monitoring backend logs for Flyway activity..."
            
            # Check if backend is running
            if ! sudo docker compose -f docker-compose.prod.yml ps backend | grep -q "Up"; then
              echo "Backend container is not running. Checking logs for errors..."
              sudo docker logs backend --tail 20
              echo "Waiting 30 seconds before next check..."
              sleep 30
              continue
            fi
            
            # Check backend logs for Flyway activity
            BACKEND_LOGS=$(sudo docker logs backend --tail 50 2>&1)
            
            if echo "$BACKEND_LOGS" | grep -q "Flyway is handling the schema migration"; then
              echo "✅ Flyway migration detected in progress..."
              break
            elif echo "$BACKEND_LOGS" | grep -q "Successfully applied"; then
              echo "✅ Flyway migrations completed successfully!"
              break
            elif echo "$BACKEND_LOGS" | grep -q "No migrations found"; then
              echo "ℹ️ No Flyway migrations needed (schema already up to date)"
              break
            elif echo "$BACKEND_LOGS" | grep -q "Started BackendApplication"; then
              echo "ℹ️ Backend started but no Flyway activity detected yet..."
            elif echo "$BACKEND_LOGS" | grep -q "Error\|Exception\|Failed"; then
              echo "❌ Backend startup error detected:"
              echo "$BACKEND_LOGS" | grep -i "error\|exception\|failed" | tail -5
            fi
            
            echo "Waiting 30 seconds before next check..."
            sleep 30
          done
          
          # Final schema check
          echo "Performing final database schema verification..."
          FINAL_TABLE_COUNT=$(sudo docker exec db2 su - db2inst1 -c "db2 connect to PHOTODB && db2 -x 'SELECT COUNT(*) FROM SYSCAT.TABLES WHERE TABSCHEMA = '\''DB2INST1'\''' | tail -1" 2>/dev/null || echo "0")
          echo "Final table count: $FINAL_TABLE_COUNT"
          
          if [ "$FINAL_TABLE_COUNT" -ge "3" ]; then
            echo "✅ Database schema verification successful - all required tables present"
          else
            echo "❌ Database schema verification failed - missing required tables"
            echo "Backend logs:"
            sudo docker logs backend --tail 100
            exit 1
          fi
          
          # Check backend logs for Flyway migration status
          echo "Checking backend logs for Flyway migration status..."
          sleep 10
          sudo docker logs backend --tail 50
          
          # Verify production profile is active and Flyway is configured
          echo "Verifying Spring Boot configuration..."
          BACKEND_LOGS=$(sudo docker logs backend --tail 100 2>&1)
          
          if echo "$BACKEND_LOGS" | grep -q "The following profiles are active: production"; then
            echo "✅ Production profile is active"
          else
            echo "❌ Production profile not detected in logs"
          fi
          
          if echo "$BACKEND_LOGS" | grep -q "Flyway is handling the schema migration"; then
            echo "✅ Flyway migration detected"
          elif echo "$BACKEND_LOGS" | grep -q "Successfully applied"; then
            echo "✅ Flyway migrations completed"
          elif echo "$BACKEND_LOGS" | grep -q "No migrations found"; then
            echo "ℹ️ No Flyway migrations needed"
          else
            echo "❌ No Flyway activity detected in logs"
            echo "This may indicate Flyway is not properly configured or not running"
          fi
          

        EOF

    - name: Health Check
      run: |
        echo "Performing health check..."
        echo "EC2 Instance IP: ${{ steps.get-ip.outputs.instance_ip }}"
        

        
        echo "Checking backend health through frontend proxy..."
        for i in {1..5}; do
          if curl -f -s http://${{ steps.get-ip.outputs.instance_ip }}/api/health; then
            echo "Backend health check passed!"
            break
          fi
          echo "Backend health check attempt $i failed, retrying in 10 seconds..."
          sleep 10
        done
        
        echo "Checking frontend health..."
        for i in {1..5}; do
          if curl -f -s http://${{ steps.get-ip.outputs.instance_ip }}/health; then
            echo "Frontend health check passed!"
            break
          fi
          echo "Frontend health check attempt $i failed, retrying in 10 seconds..."
          sleep 10
        done
        
        echo "Checking if frontend is serving the app..."
        FRONTEND_RESPONSE=$(curl -f -s http://${{ steps.get-ip.outputs.instance_ip }}/ || echo "FAILED")
        if echo "$FRONTEND_RESPONSE" | grep -q "VueDB2SpringBoot"; then
          echo "Frontend app is being served correctly!"
        else
          echo "Frontend app might not be serving correctly"
          echo "Response received:"
          echo "$FRONTEND_RESPONSE" | head -10
        fi
        
        # Test the health endpoint specifically
        echo "Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -f -s http://${{ steps.get-ip.outputs.instance_ip }}/health || echo "FAILED")
        echo "Health endpoint response: $HEALTH_RESPONSE"
        


    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Deployment successful! Application is available at https://${{ secrets.DOMAIN_NAME }}"
        else
          echo "❌ Deployment failed!"
        fi
