name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: vuedb2springboot

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      db2:
        image: icr.io/db2_community/db2:11.5.8.0
        env:
          LICENSE: accept
          DB2INSTANCE: db2inst1
          DB2INST1_PASSWORD: passw0rd
          DBNAME: PHOTODB
          BLU: false
          ENABLE_ORACLE_COMPATIBILITY: false
          UPDATEAVAIL: NO
          TO_CREATE_SAMPLEDB: false
          REPODB: false
          IS_OSXFS: false
          PERSISTENT_HOME: true
          HADR_ENABLED: false
        ports:
          - 50000:50000
        options: >-
          --privileged
          --health-cmd "timeout 10 bash -c '</dev/tcp/localhost/50000'"
          --health-interval 30s
          --health-timeout 10s
          --health-retries 10
          --health-start-period 120s

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Wait for DB2 to be ready
      run: |
        echo "Waiting for DB2 to be ready..."
        for i in {1..30}; do
          if timeout 10 bash -c '</dev/tcp/localhost/50000'; then
            echo "DB2 is ready!"
            break
          fi
          echo "Attempt $i: DB2 not ready yet, waiting 10 seconds..."
          sleep 10
        done

    - name: Run backend tests
      run: |
        cd backend
        mvn clean test -Dspring.profiles.active=db2 -Ddb.url=jdbc:db2://localhost:50000/PHOTODB -Ddb.user=db2inst1 -Ddb.pass=passw0rd
      env:
        DB_URL: jdbc:db2://localhost:50000/PHOTODB
        DB_USER: db2inst1
        DB_PASS: passw0rd

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Run frontend tests
      run: |
        cd frontend
        npm run test:unit || echo "No tests configured"

    - name: Build frontend
      run: |
        cd frontend
        npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Setup SSH key for Terraform
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa

    - name: Get SSH public key content
      id: ssh-public-key
      run: |
        # Extract public key from private key
        ssh-keygen -y -f ~/.ssh/id_rsa > ~/.ssh/id_rsa.pub
        SSH_PUBLIC_KEY=$(cat ~/.ssh/id_rsa.pub)
        echo "ssh_public_key_content=$SSH_PUBLIC_KEY" >> $GITHUB_OUTPUT

    - name: Terraform Init
      run: |
        cd terraform
        # Initialize with S3 backend for state persistence
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=vuedb2springboot/terraform.tfstate" \
          -backend-config="region=us-east-1" \
          -backend-config="encrypt=true"

    - name: Check existing infrastructure
      run: |
        cd terraform
        echo "Checking existing Terraform state..."
        terraform show || echo "No existing state found"
        echo ""
        echo "Checking existing EC2 instances..."
        aws ec2 describe-instances --filters "Name=tag:Name,Values=vuedb2springboot-web-server" --query 'Reservations[].Instances[?State.Name!=`terminated`].{InstanceId:InstanceId,State:State.Name,PublicIp:PublicIpAddress}' --output table

    - name: Handle existing key pair
      run: |
        cd terraform
        # Delete existing key pair if it exists
        aws ec2 delete-key-pair --key-name vuedb2springboot-key || echo "Key pair doesn't exist, will be created"

    - name: Handle EIP limit
      run: |
        cd terraform
        # Release unassociated EIPs to free up quota
        aws ec2 describe-addresses --query 'Addresses[?AssociationId==null].AllocationId' --output text | while read eip; do
          if [ ! -z "$eip" ]; then
            echo "Releasing unassociated EIP: $eip"
            aws ec2 release-address --allocation-id "$eip" || echo "Failed to release EIP: $eip"
          fi
        done

    - name: Clean up orphaned instances
      run: |
        cd terraform
        # Find instances with our project name that are not in Terraform state
        echo "Checking for orphaned EC2 instances..."
        ORPHANED_INSTANCES=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=vuedb2springboot-web-server" \
          --query 'Reservations[].Instances[?State.Name!=`terminated`].InstanceId' \
          --output text)
        
        if [ ! -z "$ORPHANED_INSTANCES" ]; then
          echo "Found potentially orphaned instances: $ORPHANED_INSTANCES"
          echo "Note: These will be managed by Terraform if they exist in state"
        else
          echo "No orphaned instances found"
        fi

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
          -var="ssh_public_key_content=${{ steps.ssh-public-key.outputs.ssh_public_key_content }}"

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply -auto-approve \
          -var="cloudflare_api_token=${{ secrets.CLOUDFLARE_API_TOKEN }}" \
          -var="cloudflare_zone_id=${{ secrets.CLOUDFLARE_ZONE_ID }}" \
          -var="domain_name=${{ secrets.DOMAIN_NAME }}" \
          -var="ssh_public_key_content=${{ steps.ssh-public-key.outputs.ssh_public_key_content }}"

    - name: Get EC2 Instance IP
      id: get-ip
      run: |
        cd terraform
        INSTANCE_IP=$(terraform output -raw instance_public_ip)
        echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

    - name: Wait for EC2 instance to be ready
      run: |
        echo "Waiting for EC2 instance to be ready..."
        for i in {1..30}; do
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ubuntu@${{ steps.get-ip.outputs.instance_ip }} 'echo "Instance is ready"'; then
            echo "Instance is ready!"
            break
          fi
          echo "Attempt $i: Instance not ready yet, waiting 30 seconds..."
          sleep 30
        done

    - name: Setup SSH key for deployment
      run: |
        ssh-keyscan -H ${{ steps.get-ip.outputs.instance_ip }} >> ~/.ssh/known_hosts

    - name: Deploy application
      run: |
        # Copy application files to EC2 (to temporary directory first)
        rsync -avz --delete -e "ssh -o StrictHostKeyChecking=no" \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='target' \
          --exclude='.github' \
          ./ ubuntu@${{ steps.get-ip.outputs.instance_ip }}:/tmp/${{ env.PROJECT_NAME }}/
        
        # Move files to final location with sudo
        ssh -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.instance_ip }} "
          sudo mkdir -p /opt/${{ env.PROJECT_NAME }} &&
          sudo rm -rf /opt/${{ env.PROJECT_NAME }}/* &&
          sudo mv /tmp/${{ env.PROJECT_NAME }}/* /opt/${{ env.PROJECT_NAME }}/ &&
          sudo chown -R ubuntu:ubuntu /opt/${{ env.PROJECT_NAME }}
        "

        # Deploy the application
        ssh -o StrictHostKeyChecking=no ubuntu@${{ steps.get-ip.outputs.instance_ip }} << 'EOF'
          cd /opt/${{ env.PROJECT_NAME }}
          
          # Wait for any running package operations to complete
          echo "Waiting for package operations to complete..."
          while sudo fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do
            echo "Package manager is busy, waiting..."
            sleep 5
          done
          
          # Install Docker if not present
          if ! command -v docker &> /dev/null; then
            echo "Docker not found, installing..."
            # Kill any stuck apt processes
            sudo pkill -f apt-get || true
            sudo pkill -f dpkg || true
            sleep 2
            
            # Remove any lock files
            sudo rm -f /var/lib/dpkg/lock-frontend
            sudo rm -f /var/lib/dpkg/lock
            sudo rm -f /var/cache/apt/archives/lock
            
            # Update package list
            sudo apt-get update
            
            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            
            # Create docker group if it doesn't exist
            sudo groupadd docker 2>/dev/null || true
            sudo usermod -aG docker ubuntu
          fi
          
          # Start Docker service
          sudo systemctl daemon-reload
          sudo systemctl start docker
          sudo systemctl enable docker
          
          # Wait for Docker to be ready
          echo "Waiting for Docker to be ready..."
          timeout 60 bash -c 'until docker info >/dev/null 2>&1; do sleep 2; done' || {
            echo "Docker failed to start, trying to restart..."
            sudo systemctl restart docker
            sleep 10
          }
          
          # Install Docker Compose if not present
          if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
            echo "Docker Compose not found, installing..."
            # Install Docker Compose v2 (plugin)
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            
            # Also install legacy docker-compose for compatibility
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Create .env file if it doesn't exist
          if [ ! -f .env ]; then
            echo "domain_name=${{ secrets.DOMAIN_NAME }}" > .env
          else
            # Update domain_name in .env
            if grep -q "domain_name=" .env; then
              sed -i "s/domain_name=.*/domain_name=${{ secrets.DOMAIN_NAME }}/" .env
            else
              echo "domain_name=${{ secrets.DOMAIN_NAME }}" >> .env
            fi
          fi
          
          # Verify Docker is working
          echo "Verifying Docker installation..."
          if ! sudo docker info >/dev/null 2>&1; then
            echo "Docker is not responding, attempting to fix..."
            sudo systemctl restart docker
            sleep 5
            if ! sudo docker info >/dev/null 2>&1; then
              echo "Docker is still not working, trying alternative approach..."
              sudo service docker restart
              sleep 5
            fi
          fi
          
          # Check Docker and Docker Compose versions
          echo "Docker version:"
          sudo docker --version
          echo "Docker Compose version:"
          sudo docker compose version || sudo docker-compose --version
          
          # Stop existing containers
          echo "Stopping existing containers..."
          sudo docker compose -f docker-compose.prod.yml down || sudo docker-compose -f docker-compose.prod.yml down || true
          
          # Build and start new containers
          echo "Building and starting new containers..."
          sudo docker compose -f docker-compose.prod.yml up -d --build || sudo docker-compose -f docker-compose.prod.yml up -d --build
          
          # Wait for services to be ready
          echo "Waiting for services to start..."
          sleep 30
        EOF

    - name: Health Check
      run: |
        echo "Performing health check..."
        for i in {1..10}; do
          if curl -f -s http://${{ steps.get-ip.outputs.instance_ip }}/health; then
            echo "Health check passed!"
            break
          fi
          echo "Health check attempt $i failed, retrying in 30 seconds..."
          sleep 30
        done

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ Deployment successful! Application is available at https://${{ secrets.DOMAIN_NAME }}"
        else
          echo "❌ Deployment failed!"
        fi
